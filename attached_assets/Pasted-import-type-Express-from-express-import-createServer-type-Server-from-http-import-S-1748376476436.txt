import type { Express } from "express";
import { createServer, type Server } from "http";
import Stripe from "stripe";
import { generatePDFReport } from "./report";
import { neon } from "@neondatabase/serverless";

const sql = neon(process.env.DATABASE_URL!);

// Stripe secret key from environment variables
const stripeSecretKey = process.env.STRIPE_SECRET_KEY;
if (!stripeSecretKey) {
  console.error("STRIPE_SECRET_KEY environment variable is missing");
  throw new Error("STRIPE_SECRET_KEY environment variable is required");
}

const stripe = new Stripe(stripeSecretKey, {
  apiVersion: "2025-04-30.basil",
});

export async function registerRoutes(app: Express): Promise<Server> {
  // 1️⃣ Create Audit & Payment Intent in one step
  app.post("/api/create-payment-intent", async (req, res) => {
    try {
      const { zipCode, primaryHazard } = req.body;
      console.log("Creating audit and payment intent for:", zipCode, primaryHazard);

      // Insert audit record
      const insertResult = await sql`
        INSERT INTO audits (zip, hazard)
        VALUES (${zipCode}, ${primaryHazard})
        RETURNING id
      `;
      const auditId = insertResult[0].id;

      // Create Stripe PaymentIntent with auditId metadata
      const paymentIntent = await stripe.paymentIntents.create({
        amount: 2900, // $29.00 in cents
        currency: "usd",
        metadata: {
          auditId: auditId.toString(),
          zipCode,
          primaryHazard,
        },
      });

      // Return client secret and auditId so the front-end can continue
      res.json({
        clientSecret: paymentIntent.client_secret,
        paymentIntentId: paymentIntent.id,
        auditId,
      });
    } catch (error: any) {
      console.error("Error in create-payment-intent:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // 2️⃣ Update questionnaire responses
  app.patch("/api/audits/:id", async (req, res) => {
    try {
      const auditId = parseInt(req.params.id, 10);
      const { questionnaireResponses } = req.body;

      console.log("Saving responses for audit:", auditId);
      if (questionnaireResponses) {
        for (const [questionKey, answer] of Object.entries(questionnaireResponses)) {
          if (answer) {
            await sql`
              INSERT INTO answers (audit_id, question_id, answer_text)
              VALUES (${auditId}, ${questionKey}, ${answer as string})
              ON CONFLICT DO NOTHING
            `;
          }
        }
      }

      const [audit] = await sql`
        SELECT * FROM audits WHERE id = ${auditId}
      `;
      res.json(audit);
    } catch (error: any) {
      console.error("Error saving responses:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // 3️⃣ Fetch audit by ID
  app.get("/api/audits/:id", async (req, res) => {
    try {
      const auditId = parseInt(req.params.id, 10);
      const [audit] = await sql`
        SELECT id, zip AS zipCode, hazard AS primaryHazard, created_at
        FROM audits WHERE id = ${auditId}
      `;
      if (!audit) return res.status(404).json({ message: "Audit not found" });

      const responses = await sql`
        SELECT question_id, answer_text
        FROM answers WHERE audit_id = ${auditId}
      `;
      audit.questionnaireResponses = {};
      for (const row of responses) {
        audit.questionnaireResponses[row.question_id] = row.answer_text;
      }
      res.json(audit);
    } catch (error: any) {
      console.error("Error fetching audit:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // 4️⃣ Generate PDF report
  app.post("/api/audits/:id/generate-pdf", generatePDFReport);

  // 5️⃣ Hazard detection by ZIP code
  app.get("/api/hazards/:zipCode", (req, res) => {
    try {
      const zipCode = req.params.zipCode;
      const data = getEnhancedRegionalHazardData(zipCode);
      res.json(data);
    } catch (error: any) {
      console.error("Hazard detection error:", error);
      res.status(500).json({ message: error.message });
    }
  });

  return createServer(app);
}

// Helper: ZIP-based hazard mapping
function getEnhancedRegionalHazardData(zipCode: string) {
  const regionalHazardMap: Record<string, any> = { /* ... */ };
  const twoDigit = zipCode.slice(0, 2);
  let hazardInfo = regionalHazardMap[twoDigit];
  if (!hazardInfo) {
    const broadMap: Record<string, any> = { /* ... */ };
    hazardInfo = broadMap[zipCode[0]] || { primaryHazard: "Flood", risk: 2, state: "Unknown" };
  }
  return {
    zipCode,
    primaryHazard: hazardInfo.primaryHazard,
    primaryRisk: hazardInfo.risk,
    state: hazardInfo.state,
    confidence: "high",
    dataSource: "Regional Analysis",
    lastUpdated: new Date().toISOString(),
  };
}
